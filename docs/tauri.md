# vget Desktop App - Tauri Implementation Plan

## Goal
Build a desktop app version of vget using Tauri 2.0 with React frontend and Rust backend, matching the tech stack from maily.

---

## Tech Stack (Aligned with maily)

### Frontend
- **React** 19.x
- **Vite** 7.x with `@vitejs/plugin-react`
- **TanStack Router** (file-based routing)
- **Tailwind CSS** 4.x via `@tailwindcss/vite`
- **shadcn/ui** (new-york style) with Radix primitives
- **Zustand** 5.x for state management
- **lucide-react** for icons
- **sonner** for toasts
- **bun** as package manager

### Backend (Rust)
- **Tauri** 2.0
- **tokio** for async runtime
- **reqwest** for HTTP client
- **serde** + serde_json + serde_yaml
- **rusqlite** for local database (download history)
- **dirs** for config paths
- **tauri-plugin-dialog** for file dialogs
- **tauri-plugin-updater** for auto-updates
- **tauri-plugin-process** for app control

### vget-specific Rust crates
- **m3u8-rs** for HLS parsing
- **aes** + **cbc** for HLS decryption
- **chromiumoxide** for browser automation (Xiaohongshu)
- **ffmpeg-sidecar** for video/audio merging

---

## Project Structure

```
vget-desktop/
├── package.json
├── bun.lock
├── vite.config.ts
├── tsconfig.json
├── components.json          # shadcn/ui config
├── index.html
├── Makefile
│
├── src/                     # React frontend
│   ├── main.tsx
│   ├── index.css
│   ├── routeTree.gen.ts    # Auto-generated by TanStack
│   ├── routes/
│   │   ├── __root.tsx
│   │   ├── index.tsx       # Main download page
│   │   ├── history.tsx     # Download history
│   │   └── settings.tsx    # Configuration
│   ├── components/
│   │   ├── ui/             # shadcn/ui components
│   │   ├── URLInput.tsx
│   │   ├── DownloadCard.tsx
│   │   ├── ProgressBar.tsx
│   │   ├── FormatSelector.tsx
│   │   └── UpdateNotification.tsx
│   ├── stores/
│   │   ├── downloads.ts    # Download queue state
│   │   └── config.ts       # App config state
│   ├── hooks/
│   │   └── useDownload.ts
│   └── lib/
│       └── utils.ts
│
├── src-tauri/
│   ├── Cargo.toml
│   ├── tauri.conf.json
│   ├── build.rs
│   ├── icons/
│   └── src/
│       ├── main.rs
│       ├── lib.rs          # Tauri commands registration
│       ├── config.rs       # Config management
│       ├── db.rs           # SQLite for history
│       ├── extractor/      # Site extractors
│       │   ├── mod.rs      # Extractor trait + registry
│       │   ├── types.rs    # Media types
│       │   ├── direct.rs
│       │   ├── m3u8.rs
│       │   ├── twitter.rs
│       │   ├── bilibili.rs
│       │   ├── xiaoyuzhou.rs
│       │   ├── itunes.rs
│       │   ├── xiaohongshu.rs
│       │   └── youtube.rs
│       ├── downloader/
│       │   ├── mod.rs
│       │   ├── simple.rs
│       │   ├── multistream.rs
│       │   └── hls.rs
│       └── ffmpeg.rs
│
└── public/
    └── favicon.ico
```

---

## Implementation Phases

### Phase 1: Project Setup
1. Create new Tauri 2.0 project with React + TypeScript template
2. Configure Vite with TanStack Router plugin and Tailwind
3. Setup shadcn/ui with new-york style
4. Create basic Rust module structure
5. Configure tauri.conf.json with app metadata

**Files to create:**
- `package.json`, `vite.config.ts`, `tsconfig.json`
- `components.json`, `src/index.css`
- `src-tauri/Cargo.toml`, `src-tauri/tauri.conf.json`
- Basic route files and lib.rs

### Phase 2: Core Types & Direct Downloads
1. Define Rust types: `Media`, `VideoMedia`, `AudioMedia`, `ImageMedia`, `Format`
2. Implement `Extractor` trait and registry pattern
3. Implement `DirectExtractor` (file URL detection)
4. Implement simple HTTP downloader with progress events
5. Create frontend: URL input, progress display, basic settings

**Tauri commands:**
```rust
#[tauri::command]
async fn extract_media(url: String) -> Result<MediaInfo, String>

#[tauri::command]
async fn start_download(url: String, output_path: String, format_id: Option<String>) -> Result<String, String>

#[tauri::command]
fn cancel_download(job_id: String) -> Result<(), String>

#[tauri::command]
fn get_config() -> Result<Config, String>

#[tauri::command]
fn save_config(config: Config) -> Result<(), String>
```

### Phase 3: Core Extractors
1. **M3U8Extractor** - HLS stream detection
2. **TwitterExtractor** - Syndication API + GraphQL fallback
3. **BilibiliExtractor** - WBI signing, DASH streams
4. **XiaoyuzhouExtractor** - Podcast episodes
5. **iTunesExtractor** - Apple Podcasts

### Phase 4: Advanced Downloaders
1. **Multi-stream downloader** - 12 parallel streams with resume
2. **HLS downloader** - M3U8 parsing, segment download, AES decryption
3. **FFmpeg integration** - Bundle ffmpeg-sidecar for merging

### Phase 5: Browser Automation
1. Integrate chromiumoxide for browser automation
2. Implement stealth techniques (anti-bot detection)
3. **XiaohongshuExtractor** - Browser-based extraction
4. Cookie persistence for authenticated sites

### Phase 6: Polish & Distribution
1. Download history with SQLite
2. Auto-updater configuration
3. i18n support (start with en, zh)
4. Cross-platform testing and builds
5. GitHub releases setup

---

## Key Tauri Commands (Full List)

```rust
// Extraction
extract_media(url: String) -> Result<MediaInfo, String>

// Downloads
start_download(url: String, output_path: String, format_id: Option<String>) -> Result<String, String>
cancel_download(job_id: String) -> Result<(), String>
get_download_status(job_id: String) -> Result<DownloadStatus, String>

// Config
get_config() -> Result<Config, String>
save_config(config: Config) -> Result<(), String>
select_output_directory() -> Result<Option<String>, String>

// History
list_downloads(limit: usize, offset: usize) -> Result<Vec<DownloadRecord>, String>
clear_history() -> Result<(), String>
```

**Events (Rust → Frontend):**
- `download-progress` - Progress updates
- `download-complete` - Download finished
- `download-error` - Download failed

---

## Rust Dependencies (Cargo.toml)

```toml
[dependencies]
tauri = { version = "2", features = [] }
tauri-plugin-dialog = "2"
tauri-plugin-updater = "2"
tauri-plugin-process = "2"
tauri-plugin-opener = "2"

serde = { version = "1", features = ["derive"] }
serde_json = "1"
serde_yaml = "0.9"

tokio = { version = "1", features = ["rt-multi-thread", "sync", "time", "fs"] }
reqwest = { version = "0.12", features = ["json", "cookies", "gzip", "stream"] }

rusqlite = { version = "0.32", features = ["bundled"] }
dirs = "6"
uuid = { version = "1", features = ["v4", "serde"] }
chrono = { version = "0.4", features = ["serde"] }

# HLS
m3u8-rs = "6"
aes = "0.8"
cbc = "0.1"
hex = "0.4"

# FFmpeg
ffmpeg-sidecar = "2"

# Browser automation (for Xiaohongshu)
chromiumoxide = { version = "0.7", optional = true }

[features]
default = []
browser = ["chromiumoxide"]
```

---

## Frontend Dependencies (package.json)

```json
{
  "dependencies": {
    "@tauri-apps/api": "^2",
    "@tauri-apps/plugin-dialog": "^2",
    "@tauri-apps/plugin-updater": "^2",
    "@tauri-apps/plugin-process": "^2",
    "@tanstack/react-router": "^1.147",
    "zustand": "^5",
    "react": "^19",
    "react-dom": "^19",
    "lucide-react": "^0.562",
    "sonner": "^2",
    "tailwindcss": "^4.1",
    "class-variance-authority": "^0.7",
    "clsx": "^2.1",
    "tailwind-merge": "^3.4"
  },
  "devDependencies": {
    "@tanstack/router-plugin": "^1.149",
    "@tauri-apps/cli": "^2",
    "@tailwindcss/vite": "^4.1",
    "@vitejs/plugin-react": "^4.6",
    "typescript": "~5.8",
    "vite": "^7"
  }
}
```

---

## Extractor Priority (What to Build First)

| Order | Extractor | Effort | Notes |
|-------|-----------|--------|-------|
| 1 | Direct | Low | Foundation - file URL detection |
| 2 | M3U8 | Medium | HLS support, needed by others |
| 3 | Twitter | Medium | Popular, API-based |
| 4 | Bilibili | Medium | WBI signing complexity |
| 5 | Xiaoyuzhou | Low | Simple HTML parsing |
| 6 | iTunes | Low | RSS/JSON API |
| 7 | YouTube | Medium | yt-dlp subprocess wrapper |
| 8 | Xiaohongshu | High | Browser automation required |

---

## Verification

1. **Build test:** `cd src-tauri && cargo build`
2. **Dev mode:** `bun tauri dev`
3. **Test download:** Paste a Twitter/Bilibili URL and verify download completes
4. **Test progress:** Verify real-time progress updates in UI
5. **Test config:** Change output directory, verify persistence
6. **Production build:** `bun tauri build`

---

## Release Strategy

### Separate Release Cycles

CLI and Desktop have independent release cycles to allow focused development on either without forcing synchronized releases.

### Git Tags

| Product | Version Tags | Latest Tag | Example |
|---------|--------------|------------|---------|
| CLI | `v0.x.x` | `latest` | `v0.12.13` |
| Desktop | `desktop-v0.x.x` | `desktop-latest` | `desktop-v0.1.0` |

### Auto-Updater Endpoints

- **CLI**: Checks `https://github.com/guiyumin/vget/releases/download/latest/...`
- **Desktop**: Checks `https://github.com/guiyumin/vget/releases/download/desktop-latest/latest.json`

### Release Workflow

**CLI Release:**
```bash
# 1. Update version in internal/version/version.go
# 2. Commit and tag
git tag v0.12.13
git push origin v0.12.13

# 3. Update 'latest' tag
git tag -f latest
git push -f origin latest
```

**Desktop Release:**
```bash
# 1. Update version in tauri/src-tauri/tauri.conf.json
# 2. Commit and tag
git tag desktop-v0.1.0
git push origin desktop-v0.1.0

# 3. Update 'desktop-latest' tag
git tag -f desktop-latest
git push -f origin desktop-latest
```

### Benefits

1. **Independent cycles** - Release CLI bug fixes without waiting for Desktop features
2. **Focused development** - Work on one product at a time without pressure
3. **Backward compatibility** - Existing CLI users continue getting updates from `latest`
4. **Clear separation** - Easy to track which version is which
5. **GitHub Actions** - Can have separate workflows triggered by tag patterns:
   - `v*` → Build CLI binaries
   - `desktop-v*` → Build Desktop app bundles

### GitHub Actions Setup (Recommended)

```yaml
# .github/workflows/release-cli.yml
on:
  push:
    tags:
      - 'v*'

# .github/workflows/release-desktop.yml
on:
  push:
    tags:
      - 'desktop-v*'
```

---

## Shared Config Directory

CLI and Desktop share the same config directory at `~/.config/vget/`. This ensures settings sync between both apps.

### Directory Structure

```
~/.config/vget/
├── config.yml              # Main configuration (shared by CLI & Desktop)
├── update.key              # Desktop auto-updater signing key (private)
├── update.key.pub          # Desktop auto-updater signing key (public)
├── auth.json               # Authentication tokens
├── xhs_cookies.json        # Xiaohongshu browser cookies
├── youtube_session.json    # YouTube session data
└── telegram/               # Telegram MTProto session
    └── session
```

### config.yml Format

```yaml
# vget configuration file
# Shared between CLI and Desktop

# Basic settings
language: zh                          # en, zh, jp, kr, es, fr, de
output_dir: /Users/yumin/Downloads/vget
format: mp4                           # mp4, webm, best
quality: best                         # best, 1080p, 720p, 480p

# WebDAV servers (for cloud storage like PikPak)
webdavServers:
    pikpak:
        url: https://dav.mypikpak.com
        username: your_username
        password: your_password

# Twitter/X authentication
twitter:
    auth_token: your_auth_token       # Required for NSFW content

# Bilibili authentication
bilibili:
    cookie: SESSDATA=xxx; bili_jct=xxx; DedeUserID=xxx

# Server mode settings (CLI only)
server:
    max_concurrent: 10

# Express tracking (CLI only)
express:
    kuaidi100:
        customer: xxx
        key: xxx
```

### Config File Locations by Platform

| Platform | Path |
|----------|------|
| macOS | `~/.config/vget/config.yml` |
| Linux | `~/.config/vget/config.yml` |
| Windows | `%USERPROFILE%\.config\vget\config.yml` |

**Note:** Desktop does NOT use `~/Library/Application Support/` on macOS to maintain compatibility with CLI.

### Rust Config Struct

```rust
// src-tauri/src/config.rs

pub struct Config {
    pub language: String,
    pub output_dir: String,
    pub format: String,
    pub quality: String,
    #[serde(rename = "webdavServers")]
    pub webdav_servers: HashMap<String, WebDAVServer>,
    pub twitter: TwitterConfig,
    pub bilibili: BilibiliConfig,
    pub server: ServerConfig,
    pub express: ExpressConfig,
}

pub struct TwitterConfig {
    pub auth_token: Option<String>,
}

pub struct BilibiliConfig {
    pub cookie: Option<String>,
}

pub struct WebDAVServer {
    pub url: String,
    pub username: String,
    pub password: String,
}
```

### TypeScript Config Interface

```typescript
// src/components/settings/types.ts

interface Config {
  language: string;
  output_dir: string;
  format: string;
  quality: string;
  webdav_servers: Record<string, WebDAVServer>;
  twitter: { auth_token: string | null };
  bilibili: { cookie: string | null };
  server: { max_concurrent: number };
  express: { kuaidi100: Kuaidi100Config | null };
}
```
